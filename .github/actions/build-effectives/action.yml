name: Build effective configs
description: Inject exclude list and write *.effective.yaml for largecap configs

inputs:
  env-file:
    description: Path to .env file
    required: false
    default: .github/workflows/largecap-watch.env
  map-file:
    description: Path to symbol->id map yaml
    required: false
    default: configs/symbol_to_id.yaml
  configs:
    description: Space-separated config list
    required: false
    default: "config_largecap.yaml config_largecap_btc.yaml config_largecap_compare.yaml"

outputs:
  effective_list:
    description: "newline-separated list of generated effective yaml paths"
    value: ${{ steps.build.outputs.effective_list }}

runs:
  using: "composite"
  steps:
    - uses: actions/setup-python@v5
      with:
        python-version: "3.11"
        cache: "pip"

    - name: Install minimal deps for build-effectives
      shell: bash
      working-directory: ${{ github.workspace }}
      run: |
        set -euo pipefail
        python -m pip install -U pip
        pip install pyyaml

    - name: Load .env into GITHUB_ENV (sans comments/webhook)
      shell: bash
      working-directory: ${{ github.workspace }}
      run: |
        set -euo pipefail
        sed -e 's/\r$//' "${{ inputs.env-file }}" \
          | grep -Ev '^[[:space:]]*($|#)|^[[:space:]]*DISCORD_WEBHOOK(_URL)?=' >> "$GITHUB_ENV" || true
        echo "[LOG] PWD=$(pwd)"
        echo "[LOG] LARGECAP_EXCLUDE=${LARGECAP_EXCLUDE:-[]}"

    - name: Build effective YAMLs
      id: build
      shell: bash
      working-directory: ${{ github.workspace }}
      run: |
        set -euo pipefail
        python - <<'PY'
        import os, json, yaml, pathlib

        env_ex = os.environ.get("LARGECAP_EXCLUDE","[]")
        try:
            ex_list = json.loads(env_ex)
        except Exception:
            ex_list = []
        if not isinstance(ex_list, list):
            ex_list = []

        map_path = pathlib.Path("${{ inputs.map-file }}")
        mp = yaml.safe_load(map_path.read_text(encoding="utf-8")) if map_path.exists() else {}
        mp = mp or {}

        def sym_to_ids(sym):
            v = mp.get(str(sym).upper(), sym)
            return v if isinstance(v, list) else [v]

        ex_ids = sorted({str(x) for s in ex_list for x in sym_to_ids(s) if x})

        cfg_raw = """${{ inputs.configs }}"""
        cfg_files = cfg_raw.split()

        out_paths = []
        for base in cfg_files:
            p = pathlib.Path(base)
            if not p.exists():
                print(f"[skip] {base}")
                continue

            data = yaml.safe_load(p.read_text(encoding="utf-8")) or {}
            cur = data.get("exclude_ids") or []
            if not isinstance(cur, list):
                cur = [cur]
            cur = [str(x) for x in cur if x]

            merged = sorted({*cur, *ex_ids})
            data["exclude_ids"] = merged
            data["exclude"] = merged

            out = p.with_suffix(".effective.yaml")
            out.write_text(
                yaml.safe_dump(data, allow_unicode=True, sort_keys=False),
                encoding="utf-8"
            )
            print(f"[OK] wrote {out} exclude_ids={len(merged)}")
            out_paths.append(str(out))

        # outputs
        with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
            fh.write("effective_list=" + "\\n".join(out_paths) + "\n")
        PY

